(() => {
  // run when DOM ready
  function onReady(fn){
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn);
    else fn();
  }

  onReady(() => {
    try {
      // insert safe style (guard head)
      const head = document.head || document.getElementsByTagName('head')[0] || document.documentElement;
      const style = document.createElement('style');
      style.textContent = `
        html,body{height:100%;margin:0;padding:0;background:#000;overflow:hidden}
        .matrix-container{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
        #matrix{display:block}
        .ascii-art{
          position:absolute;
          left:50%;
          top:50%;
          transform:translate(-50%,-50%) scale(1);
          transform-origin:center center;
          color:#00ff99;
          white-space:pre;
          text-align:center;
          font-family:monospace;
          line-height:1;
          pointer-events:none;
          max-width:92vw;
          max-height:78vh;
          overflow:hidden;
        }
      `;
      head.appendChild(style);

      // create container and elements (guard body)
      const body = document.body || document.getElementsByTagName('body')[0] || document.documentElement;
      const container = document.createElement('div');
      container.className = 'matrix-container';

      const canvas = document.createElement('canvas');
      canvas.id = 'matrix';
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      container.appendChild(canvas);

      const art = document.createElement('pre');
      art.className = 'ascii-art';
      art.textContent = `
  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀    Кто я ?
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡀⠀⠀⢀⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣤⣤⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⢿⣿⣿⣿⣿⣿⣿⡿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢀⣀⣠⠀⣶⣤⣄⣉⣉⣉⣉⣠⣤⣶⠀⣄⣀⡀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⣶⣾⣿⣿⣿⣿⣦⣄⣉⣙⣛⣛⣛⣛⣋⣉⣠⣴⣿⣿⣿⣿⣷⣶⠀⠀⠀
⠀⠀⠀⠀⠈⠉⠉⠛⠛⠛⠻⠿⠿⠿⠿⠿⠿⠿⠿⠟⠛⠛⠛⠉⠉⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣷⣆⠀⠀⠀⢠⡄⠀⠀⠀⣰⣾⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢀⣠⣶⣾⣿⡆⠸⣿⣶⣶⣾⣿⣿⣷⣶⣶⣿⠇⢰⣿⣷⣶⣄⡀⠀⠀⠀
⠀⠀⠺⠿⣿⣿⣿⣿⣿⣄⠙⢿⣿⣿⣿⣿⣿⣿⡿⠋⣠⣿⣿⣿⣿⣿⠿⠗⠀⠀
⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣷⡄⠈⠙⠛⠛⠋⠁⢠⣾⣿⣿⣿⠟⠋⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣀⣤⣬⣿⣿⣿⣇⠐⣿⣿⣿⣿⠂⣸⣿⣿⣿⣥⣤⣀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠘⠻⠿⠿⢿⣿⣿⣿⣧⠈⠿⠿⠁⣼⣿⣿⣿⡿⠿⠿⠟⠃⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢿⠀⣶⣦⠀⡿⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
        Maptnh@S-H4CK13   ⠀⠀
  `;
      container.appendChild(art);

      body.appendChild(container);

      // drawing vars
      const ctx = canvas.getContext('2d', { alpha: false });
      const characters = 'S-H4CK13 Maptnh Russia';
      const charsArr = characters.split('');
      const FONT_PX = 16; // logical px for layout
      let dpr = Math.max(1, window.devicePixelRatio || 1);
      let width = 0, height = 0;
      let columns = 0;
      let drops = [];

      function initCanvasSize() {
        dpr = Math.max(1, window.devicePixelRatio || 1);
        // set actual pixel size
        width = Math.floor(window.innerWidth);
        height = Math.floor(window.innerHeight);
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        // keep CSS size
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        // scale context so we can draw in CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // compute columns in CSS pixels
        columns = Math.max(2, Math.floor(width / FONT_PX));
        // recreate drops
        drops = new Array(columns).fill(0).map(() => Math.floor(Math.random() * Math.floor(height / FONT_PX)));
        // art scale/position: measure then scale to fit max bounds
        requestAnimationFrame(() => {
          const rect = art.getBoundingClientRect();
          const maxW = Math.floor(window.innerWidth * 0.92);
          const maxH = Math.floor(window.innerHeight * 0.7);
          const scale = Math.min(1, maxW / Math.max(1, rect.width), maxH / Math.max(1, rect.height));
          art.style.transform = `translate(-50%,-50%) scale(${scale})`;
        });
      }

      // draw one frame
      function drawFrame() {
        // fade trail: adjust alpha for longer/shorter trails
        ctx.fillStyle = 'rgba(0,0,0,0.06)';
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = '#aaaaaa';
        ctx.font = FONT_PX + 'px monospace';
        ctx.textBaseline = 'top';

        for (let i = 0; i < columns; i++) {
          const ch = charsArr[(Math.random() * charsArr.length) | 0];
          const x = i * FONT_PX;
          const y = drops[i] * FONT_PX;
          ctx.fillText(ch, x, y);

          // advance with occasional reset — tuned probability for continuity
          if (y > height && Math.random() > 0.995) drops[i] = 0;
          drops[i]++;
          if (drops[i] * FONT_PX > height) drops[i] = 0;
        }
      }

      let raf = null;
      function loop() {
        drawFrame();
        raf = requestAnimationFrame(loop);
      }

      // initial
      initCanvasSize();
      loop();

      // resize debounce
      let t;
      window.addEventListener('resize', () => {
        clearTimeout(t);
        t = setTimeout(() => {
          initCanvasSize();
        }, 100);
      });

      // expose control for debugging
      window.__matrix_stop = () => { if (raf) cancelAnimationFrame(raf); };
      window.__matrix_restart = () => { if (!raf) loop(); };
    } catch (e) {
      console.error('matrix init error:', e);
    }
  });
})();
